# [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

## é¢˜ç›®
Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given
```
inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
```
Return the following binary tree:
```
    3
   / \
  9  20
    /  \
   15   7
```

## é¢˜ç›®å¤§æ„
é€šè¿‡æ‰€ç»™çš„ä¸­åºéå†å’Œååºéå†æ¥æ„é€ å‡ºäºŒå‰æ ‘

## åˆ†æ
```
1. è¦æƒ³å»ºç«‹äºŒå‰æ ‘é‚£ä¹ˆå…³é”®çš„æ˜¯è¦æ‰¾åˆ°äºŒå‰çš„æ ¹èŠ‚ç‚¹ç„¶ååˆ›å»ºå®ƒ
2. å†ä¾é äºŒå‰æ ‘çš„éå†æ¡†æ¶æŠŠæ‰€æœ‰çš„ç»“ç‚¹éƒ½å»ºç«‹èµ·æ¥
```
é‚£ä¹ˆé—®é¢˜çš„æˆ‘ä»¬æ€ä¹ˆå»å¾—åˆ°æ ¹èŠ‚ç‚¹ï¼Ÿ
---
ä¸­åºéå†ï¼šå·¦ æ ¹ å³

ååºéå†ï¼šå·¦ å³ æ ¹

ä»æ ¹çš„ååºéå†çš„æœ€åä¸€ä¸ªæˆ‘ä»¬å°±å¯ä»¥çŸ¥é“æ ¹ç»“ç‚¹æ˜¯ä»€ä¹ˆ

å†ä½¿ç”¨å¾ªç¯åœ¨ä¸­åºéå†æŸ¥æ‰¾æ ¹çš„ç´¢å¼•å°±å¯ä»¥çŸ¥é“é‚£äº›å…ƒç´ æ˜¯æ ¹çš„å·¦å­æ ‘å…ƒç´  ä»€ä¹ˆæ˜¯æ ¹çš„å³å­æ ‘å…ƒç´ 

å»ºç«‹å¥½æ ¹ç»“ç‚¹å†é€’å½’å»ºç«‹å¥½å·¦å­æ ‘å’Œå³å­æ ‘

## è§£å†³ä»£ç  (C++)
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector<int>& inorder, int left1, int right1, vector<int>& postorder, int left2, int right2){
        if(left1 > right1) return NULL;

        int index;
        //æ‰¾å‡ºæ ¹èŠ‚ç‚¹åœ¨ä¸­åºéå†çš„ç´¢å¼•
        for(int i = left1; i <= right1; i++){
            if(inorder[i] == postorder[right2]){
                index = i;
                
            }
        }

        int leftsize = index - left1;  //å·¦å­æ ‘çš„é•¿åº¦
        int rightsize = right1 - index;  //å³å­æ ‘çš„é•¿åº¦

        TreeNode* T = new TreeNode(postorder[right2]);

        T->left = build(inorder, left1, index - 1, postorder, left2, left2 + leftsize - 1);
        T->right = build(inorder, index + 1, right1, postorder, left2 + leftsize, right2 - 1);

        return T;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);
    }
};
```

## å¿ƒå¾—ä½“ä¼šğŸˆ

```
for(int i = left1; i <= right1; i++){
            if(inorder[i] == postorder[right2]){
                index = i;
                break;
            }
        }
```
å½“æˆ‘ä½¿ç”¨è¿™æ ·çš„ä»£ç å»å¯»æ‰¾æ ¹èŠ‚ç‚¹åœ¨ä¸­åºçš„ç´¢å¼•æ—¶leetcodeå‡ºç°runtime error å‘ç°æ˜¯ overflow 
```
 int max = INT_MIN; int t;
        for(int i = left; i <= right; i++){
            if(max < nums[i]){
                max = nums[i];
                t = i;
                breakï¼›
            }
        }
``
ä½¿ç”¨breakå°±ä¸ä¼šæŠ¥é”™ã€‚

## èµ„æ–™
éƒ½æ˜¯çœ‹ğŸ“Œâ¡æˆ‘å•¥éƒ½ä¸æ‡‚ğŸ¤§[ä¸œå“¥æ‰‹æŠŠæ‰‹å¸¦ä½ åˆ·äºŒå‰æ ‘]ï¼ˆhttps://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487270&idx=1&sn=2f7ad74aabc88b53d94012ceccbe51be&chksm=9bd7f12eaca078384733168971147866c140496cb257946f8170f05e46d16099f3eef98d39d9&scene=21#wechat_redirectï¼‰
