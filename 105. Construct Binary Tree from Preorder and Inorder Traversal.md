# [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

## é¢˜ç›®
Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given
```
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```
Return the following binary tree:
```

    3
   / \
  9  20
    /  \
   15   7
```

## é¢˜ç›®å¤§æ„
ç»™äºŒå‰æ ‘çš„å…ˆåºéå†å’Œä¸­åºéå†çš„æ•°ç»„æ„é€ å‡ºäºŒå‰æ ‘

## åˆ†æ
+ äºŒå‰æ ‘çš„å…ˆåºéå†ï¼šæ ¹ å·¦ å³ äºŒå‰æ ‘ä¸­åºéå†ï¼šå·¦ å³ æ ¹ é€šè¿‡è¿™å¯ä»¥åˆ¤æ–­å‡ºå“ªäº›éƒ¨åˆ†æ˜¯å·¦å­æ ‘ é‚£äº›æ˜¯å³å­æ ‘
+ ä¸æ–­åœ°æ‰¾å‡ºæ ¹ åœ¨æŠŠæ•°ç»„æ‹†åˆ†æˆå·¦ æ ¹ å³ é€’å½’åˆ›å»º

## ä»£ç 
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
   TreeNode* build(vector<int>& preorder, int left1, int right1, vector<int>& inorder, int left2, int right2){
            int index;
            if(left1 > right1) return NULL;

            for(int i = left2; i <= right2; i++){
                if(preorder[left1] == inorder[i]){
                    index = i;  //æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„å€¼ å¹¶è®°å½•ä¸‹å®ƒåœ¨ä¸­åºéå†çš„ç´¢å¼• ä¸­åºéå†çš„å·¦è¾¹æ˜¯å®ƒçš„å·¦å­æ ‘ å³è¾¹æ˜¯å³å­æ ‘
                    break;
                }
            }
           
            int leftsize = index - left2;

            TreeNode* T = new TreeNode(preorder[left1]);

            T->left = build(preorder, left1+1, left1+leftsize, inorder, left2, index-1);
            T->right = build(preorder, left1+leftsize+1, right1, inorder, index+1, right2);

            return T;
        }


        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
            return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
        }
};
```

## è¢«ç‚¸ç‚¹ğŸ˜±
```
TreeNode* build(vector<int>& preorder, vector<int>& inorder, int left, int right)
```
+ ç¬¬ä¸€æ¬¡å‚æ•°è®¾ç½® è®¤ä¸ºæ˜¯ç›¸åŒçš„

![å¾ˆæ˜æ˜¾ä¸ä¸€æ ·å•ŠğŸ˜©](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W6cuUtHIdXvXjbicaaZnpBWzEO1ZLfCGn9ntniaEicl5Et2wiarGaSq2GCZw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

+ å®é™…ä¸Šåœ¨å¤šæ¬¡ä¹‹åæ— æ³•æœ‰é—®é¢˜
```
 T->left = build(preorder, left1+1, index, inorder, left2, index-1);
 T->right = build(preorder, index+1, right1, inorder, index+1, right2);
```
![çœ‹äº†å›¾å°±ä»¥ä¸ºæ˜¯è¿™æ ·ğŸ¤§](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W6BFJp9KicjbvfTdvhU3vaDFEqaUiaNF1q3HzkyFjnpypG8XrGzJXdpeLg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## è¢«ç‚¸æ„Ÿæƒ³
æ„Ÿè§‰ æ€ä¹ˆè¯´ å†™ä»£ç çœŸçš„æ˜¯è¦åšåˆ°æ‰€æœ‰éƒ½æ˜¯ç²¾ç¡®çš„ åœ¨æ²¡æœ‰åŠæ³•çœŸæ­£çš„æŒæ¡åˆ°æ›´å¿«çš„è§„å¾‹çš„æ—¶å€™è¦è¿½å¯»æœ€ç®€å•çš„æƒ³æ³• å°±åƒç”µè„‘ä¸ºä»€ä¹ˆä½¿ç”¨äºŒè¿›åˆ¶è€Œä¸ç”¨åè¿›åˆ¶å°±æ˜¯å› ä¸ºç”µå¹³ä¸èƒ½å¾ˆå¥½çš„åˆ†è¾© é‚£åŒæ ·ä¹Ÿå¯ä»¥å®Œæˆçš„å¾ˆå¥½å•Š çœŸçš„æ˜¯è¦åœ¨è‡ªå·±çš„æŠŠæ§ä¹‹å†… 

## å¤§é“è‡³ç®€ğŸ‡

## å¼•ç”¨
[ä¸œå“¥æ‰‹æŠŠæ‰‹å¸®ä½ åˆ·é€šäºŒå‰æ ‘](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487270&idx=1&sn=2f7ad74aabc88b53d94012ceccbe51be&chksm=9bd7f12eaca078384733168971147866c140496cb257946f8170f05e46d16099f3eef98d39d9&scene=21#wechat_redirect)
å­¦ä¹ ä¸­ğŸ±â€ğŸ’»


